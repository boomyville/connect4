<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Connect 4: AI Always Goes First</title>
  <style>
    body { 
      font-family: sans-serif; 
      text-align: center; 
      margin: 0;
      padding: 10px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      color: white;
    }
    
    .game-container {
      max-width: 100%;
      margin: 0 auto;
      padding: 20px;
    }
    
    h2 {
      font-size: clamp(1.2rem, 4vw, 2rem);
      margin: 10px 0;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    
    table { 
      margin: 20px auto; 
      border-collapse: separate;
      border-spacing: 8px;
      background: #2c3e50;
      padding: 15px;
      border-radius: 15px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.3);
      max-width: 95vw;
    }
    
    td {
      width: clamp(35px, 10vw, 60px);
      height: clamp(35px, 10vw, 60px);
      background: #34495e;
      cursor: pointer;
      border-radius: 50%;
      position: relative;
      transition: all 0.2s ease;
      border: 3px solid #2c3e50;
    }
    
    td:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    
    .piece {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: clamp(0.8rem, 2.5vw, 1.2rem);
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
      transition: all 0.3s ease;
    }
    
    .red .piece {
      background: radial-gradient(circle at 30% 30%, #ff6b6b, #e74c3c, #c0392b);
      color: white;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    }
    
    .yellow .piece {
      background: radial-gradient(circle at 30% 30%, #f1c40f, #f39c12, #e67e22);
      color: #2c3e50;
      text-shadow: 1px 1px 2px rgba(255,255,255,0.3);
    }
    
    .red .piece::before {
      content: "●";
    }
    
    .yellow .piece::before {
      content: "●";
    }
    
    button { 
      margin: 20px 10px;
      padding: 12px 24px;
      font-size: clamp(0.9rem, 3vw, 1.1rem);
      background: linear-gradient(45deg, #3498db, #2980b9);
      color: white;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.3);
    }
    
    button:active {
      transform: translateY(0);
    }
    
    /* AI Thinking Animation */
    .thinking-indicator {
      display: none;
      margin: 15px auto;
      font-size: clamp(1rem, 3vw, 1.3rem);
      color: #ecf0f1;
      background: rgba(0,0,0,0.2);
      padding: 15px 25px;
      border-radius: 25px;
      backdrop-filter: blur(10px);
      max-width: 90%;
    }
    
    .thinking-dots {
      display: inline-block;
    }
    
    .thinking-dots::after {
      content: '';
      animation: thinking 1.5s infinite;
    }
    
    @keyframes thinking {
      0% { content: '.'; }
      33% { content: '..'; }
      66% { content: '...'; }
      100% { content: '.'; }
    }
    
    .thinking-spinner {
      display: inline-block;
      width: clamp(16px, 4vw, 24px);
      height: clamp(16px, 4vw, 24px);
      border: 3px solid rgba(255,255,255,0.3);
      border-top: 3px solid #ff6b6b;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-left: 10px;
      vertical-align: middle;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    #result {
      font-size: clamp(1.2rem, 4vw, 1.8rem);
      font-weight: bold;
      margin: 20px 0;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
      background: rgba(0,0,0,0.2);
      padding: 15px;
      border-radius: 15px;
      backdrop-filter: blur(10px);
    }
    
    /* Mobile optimizations */
    @media (max-width: 480px) {
      .game-container {
        padding: 10px;
      }
      
      table {
        border-spacing: 5px;
        padding: 10px;
      }
      
      td {
        border-width: 2px;
      }
      
      h2 br {
        display: none;
      }
      
      h2::after {
        content: " - Player always goes second";
      }
    }
    
    /* Landscape phone optimization */
    @media (max-height: 500px) and (orientation: landscape) {
      .game-container {
        padding: 5px;
      }
      
      h2 {
        margin: 5px 0;
      }
      
      table {
        margin: 10px auto;
      }
      
      button {
        margin: 10px 5px;
        padding: 8px 16px;
      }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <h2>Connect 4: AI (Red) vs Player (Yellow)</h2>
    <table id="board"></table>
    <div class="thinking-indicator" id="thinkingIndicator">
      AI is thinking<span class="thinking-dots"></span>
      <div class="thinking-spinner" id="spinner" style="display:none;"></div>
    </div>
    <button onclick="resetGame()">Restart</button>
    <p id="result"></p>
  </div>
  <script>
    const ROWS = 6, COLS = 7;
    let board, gameOver, currentPlayer;
    const HUMAN = 2, AI = 1;

    function createBoard() {
      board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
      gameOver = false;
      currentPlayer = AI;
      drawBoard();
      document.getElementById('result').textContent = '';
      if (currentPlayer === AI) {
        // Show thinking indicator for AI's first move
        document.getElementById('thinkingIndicator').style.display = 'block';
        setTimeout(() => {
          aiMove();
          document.getElementById('thinkingIndicator').style.display = 'none';
        }, 400);
      }
    }
    
    function drawBoard() {
      const table = document.getElementById('board');
      table.innerHTML = '';
      for (let r = 0; r < ROWS; r++) {
        const tr = document.createElement('tr');
        for (let c = 0; c < COLS; c++) {
          const td = document.createElement('td');
          
          // Create piece element if there's a piece in this position
          if (board[r][c] !== 0) {
            const piece = document.createElement('div');
            piece.className = 'piece';
            if (board[r][c] === AI) {
              td.classList.add('red');
            } else if (board[r][c] === HUMAN) {
              td.classList.add('yellow');
            }
            td.appendChild(piece);
          }
          
          td.onclick = () => handlePlayerMove(c);
          tr.appendChild(td);
        }
        table.appendChild(tr);
      }
    }

    function handlePlayerMove(col) {
      if (gameOver || currentPlayer !== HUMAN) return;
      if (!dropDisc(col, HUMAN)) return;
      drawBoard();
      checkGame();
      if (!gameOver) {
        currentPlayer = AI;
        // Show thinking indicator
        document.getElementById('thinkingIndicator').style.display = 'block';
        setTimeout(() => {
          aiMove();
          // Hide thinking indicator after AI move
          document.getElementById('thinkingIndicator').style.display = 'none';
        }, 400);
      }
    }

    function aiMove() {
        // Advanced threat analysis with multiple levels
        
        // Level 1: Check for immediate wins
        for (let col = 0; col < COLS; col++) {
            if (canDropDisc(col)) {
                dropDisc(col, AI);
                if (winner(board, AI)) {
                    drawBoard();
                    checkGame();
                    return;
                }
                undoDropDisc(col);
            }
        }
        
        // Level 2: Block immediate human wins
        for (let col = 0; col < COLS; col++) {
            if (canDropDisc(col)) {
                dropDisc(col, HUMAN);
                if (winner(board, HUMAN)) {
                    undoDropDisc(col);
                    dropDisc(col, AI);
                    drawBoard();
                    checkGame();
                    currentPlayer = HUMAN;
                    return;
                }
                undoDropDisc(col);
            }
        }
        
        // Level 3: Check for setup moves (creating multiple threats)
        const setupMove = findSetupMove();
        if (setupMove !== -1) {
            dropDisc(setupMove, AI);
            drawBoard();
            checkGame();
            currentPlayer = HUMAN;
            return;
        }
        
        // Level 4: Prevent opponent setup moves
        const blockSetup = findOpponentSetup();
        if (blockSetup !== -1) {
            dropDisc(blockSetup, AI);
            drawBoard();
            checkGame();
            currentPlayer = HUMAN;
            return;
        }
        
        // Level 5: Use enhanced minimax with deeper search
        let [score, move] = minimax(board, 9, -Infinity, Infinity, true);
        if (move !== null) {
            dropDisc(move, AI);
        } else {
            // Fallback with advanced column preference
            const smartFallback = [3, 2, 4, 1, 5, 0, 6];
            for (let col of smartFallback) {
                if (canDropDisc(col)) {
                    dropDisc(col, AI);
                    break;
                }
            }
        }
        drawBoard();
        checkGame();
        currentPlayer = HUMAN;
    }

    // Find moves that create multiple winning opportunities
    function findSetupMove() {
        for (let col = 0; col < COLS; col++) {
            if (canDropDisc(col)) {
                dropDisc(col, AI);
                let threats = 0;
                
                // Count how many ways AI can win next turn
                for (let testCol = 0; testCol < COLS; testCol++) {
                    if (canDropDisc(testCol)) {
                        dropDisc(testCol, AI);
                        if (winner(board, AI)) threats++;
                        undoDropDisc(testCol);
                    }
                }
                
                undoDropDisc(col);
                
                // If this move creates 2+ threats, it's a winning setup
                if (threats >= 2) return col;
            }
        }
        return -1;
    }

    // Find and block opponent setup moves
    function findOpponentSetup() {
        for (let col = 0; col < COLS; col++) {
            if (canDropDisc(col)) {
                dropDisc(col, HUMAN);
                let threats = 0;
                
                // Count how many ways human can win next turn
                for (let testCol = 0; testCol < COLS; testCol++) {
                    if (canDropDisc(testCol)) {
                        dropDisc(testCol, HUMAN);
                        if (winner(board, HUMAN)) threats++;
                        undoDropDisc(testCol);
                    }
                }
                
                undoDropDisc(col);
                
                // If opponent's move would create 2+ threats, block it
                if (threats >= 2) return col;
            }
        }
        return -1;
    }

    function canDropDisc(col) {
        return board[0][col] === 0;
    }

    function undoDropDisc(col) {
        for (let r = 0; r < ROWS; r++) {
            if (board[r][col] !== 0) {
                board[r][col] = 0;
                return true;
            }
        }
        return false;
    }

    function dropDisc(col, player) {
      for (let r = ROWS - 1; r >= 0; r--) {
        if (!board[r][col]) {
          board[r][col] = player;
          return true;
        }
      }
      return false;
    }

    function checkGame() {
      if (winner(board, AI)) endGame('AI WINS!');
      else if (winner(board, HUMAN)) endGame('PLAYER WINS!');
      else if (board[0].every(cell => cell)) endGame('DRAW!');
    }
    function endGame(msg) {
      gameOver = true;
      document.getElementById('result').textContent = msg;
    }
    function winner(board, player) {
      // Check horizontal, vertical, diagonal
      for (let r = 0; r < ROWS; r++)
        for (let c = 0; c < COLS; c++)
          if (
            checkDir(r, c, 0, 1, player) ||
            checkDir(r, c, 1, 0, player) ||
            checkDir(r, c, 1, 1, player) ||
            checkDir(r, c, 1, -1, player)
          ) return true;
      return false;
    }
    function checkDir(r, c, dr, dc, player) {
      for (let i = 0; i < 4; i++)
        if (
          !board[r + dr * i] ||
          board[r + dr * i][c + dc * i] !== player
        )
          return false;
      return true;
    }
    function evaluateBoard(b, player) {
        const opponent = player === AI ? HUMAN : AI;
        let score = 0;
        
        // Enhanced center column preference with decay from center
        const centerValues = [3, 4, 5, 4, 5, 4, 3];
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                if (b[r][c] === player) {
                    score += centerValues[c];
                    // Bonus for pieces higher up (more strategic)
                    score += (ROWS - r) * 0.5;
                }
            }
        }
        
        // Evaluate all possible 4-in-a-row windows
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                // Horizontal
                if (c + 3 < COLS) {
                    score += evaluateWindow([b[r][c], b[r][c+1], b[r][c+2], b[r][c+3]], player);
                }
                // Vertical
                if (r + 3 < ROWS) {
                    score += evaluateWindow([b[r][c], b[r+1][c], b[r+2][c], b[r+3][c]], player);
                }
                // Diagonal /
                if (r + 3 < ROWS && c + 3 < COLS) {
                    score += evaluateWindow([b[r][c], b[r+1][c+1], b[r+2][c+2], b[r+3][c+3]], player);
                }
                // Diagonal \
                if (r + 3 < ROWS && c - 3 >= 0) {
                    score += evaluateWindow([b[r][c], b[r+1][c-1], b[r+2][c-2], b[r+3][c-3]], player);
                }
            }
        }
        
        // Bonus for controlling key positions
        score += evaluateControlPositions(b, player);
        
        return score;
    }

    function evaluateWindow(window, player) {
        const opponent = player === AI ? HUMAN : AI;
        let score = 0;
        
        const playerCount = window.filter(cell => cell === player).length;
        const opponentCount = window.filter(cell => cell === opponent).length;
        const emptyCount = window.filter(cell => cell === 0).length;
        
        // Can't win if opponent has pieces in this window
        if (playerCount > 0 && opponentCount > 0) return 0;
        
        if (playerCount === 4) {
            score += 10000; // Winning position
        } else if (playerCount === 3 && emptyCount === 1) {
            score += 100; // Strong threat
        } else if (playerCount === 2 && emptyCount === 2) {
            score += 10; // Building position
        } else if (playerCount === 1 && emptyCount === 3) {
            score += 1; // Potential
        }
        
        // Heavily penalize opponent opportunities
        if (opponentCount === 3 && emptyCount === 1) {
            score -= 500; // Must block this threat
        } else if (opponentCount === 2 && emptyCount === 2) {
            score -= 50; // Watch this developing threat
        }
        
        return score;
    }

    // Evaluate control of strategic positions
    function evaluateControlPositions(b, player) {
        let score = 0;
        const opponent = player === AI ? HUMAN : AI;
        
        // Control of bottom row is valuable
        for (let c = 0; c < COLS; c++) {
            if (b[ROWS-1][c] === player) score += 5;
            if (b[ROWS-1][c] === opponent) score -= 3;
        }
        
        // Control of key diagonal positions
        const keyPositions = [
            [ROWS-1, 3], [ROWS-2, 3], [ROWS-3, 3], // Center column
            [ROWS-1, 2], [ROWS-1, 4], // Adjacent to center
            [ROWS-2, 2], [ROWS-2, 4]  // Second row adjacent
        ];
        
        for (let [r, c] of keyPositions) {
            if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
                if (b[r][c] === player) score += 3;
                if (b[r][c] === opponent) score -= 2;
            }
        }
        
        return score;
    }

    function minimax(board, depth, alpha, beta, maximizing) {
        // Check terminal states with faster wins preferred
        if (winner(board, AI)) return [100000 - (9 - depth), null];
        if (winner(board, HUMAN)) return [-100000 + (9 - depth), null];
        
        const validMoves = [];
        for (let col = 0; col < COLS; col++) {
            if (canDropDisc(col)) validMoves.push(col);
        }
        
        if (depth === 0 || validMoves.length === 0) {
            const aiScore = evaluateBoard(board, AI);
            const humanScore = evaluateBoard(board, HUMAN);
            return [aiScore - humanScore, null];
        }

        // Enhanced move ordering: prioritize center, then by column activity
        validMoves.sort((a, b) => {
            const aCenterDist = Math.abs(3 - a);
            const bCenterDist = Math.abs(3 - b);
            if (aCenterDist !== bCenterDist) return aCenterDist - bCenterDist;
            
            // Secondary sort by column "activity" (how many pieces)
            const aActivity = board.reduce((sum, row) => sum + (row[a] !== 0 ? 1 : 0), 0);
            const bActivity = board.reduce((sum, row) => sum + (row[b] !== 0 ? 1 : 0), 0);
            return bActivity - aActivity; // Prefer more active columns
        });
        
        if (maximizing) {
            let value = -Infinity;
            let bestMove = validMoves[0];
            
            for (const move of validMoves) {
                dropDisc(move, AI);
                const [score] = minimax(board, depth - 1, alpha, beta, false);
                undoDropDisc(move);
                
                if (score > value) {
                    value = score;
                    bestMove = move;
                }
                alpha = Math.max(alpha, value);
                if (alpha >= beta) break; // Alpha-beta pruning
            }
            return [value, bestMove];
        } else {
            let value = Infinity;
            let bestMove = validMoves[0];
            
            for (const move of validMoves) {
                dropDisc(move, HUMAN);
                const [score] = minimax(board, depth - 1, alpha, beta, true);
                undoDropDisc(move);
                
                if (score < value) {
                    value = score;
                    bestMove = move;
                }
                beta = Math.min(beta, value);
                if (alpha >= beta) break; // Alpha-beta pruning
            }
            return [value, bestMove];
        }
    }

    function resetGame() { createBoard(); }
    createBoard();
  </script>
</body>
</html>
